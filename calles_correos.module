<?php

function calles_correos_existe_registro_id($id){
	$sql = "SELECT idregistro FROM {POSTALT} WHERE idregistro = %d";
	$result = db_result(db_query($sql,$id));
	if($result !== false)$result = TRUE;
	return $result;
}


function calles_correos_devolver_tipo_via($codigo){
	
	$query = db_result(db_query("SELECT CODVIA.descvia FROM {POSTALT} ".
							"LEFT OUTER JOIN {CODVIA} ON POSTALT.codvia = CODVIA.codvia ".
							"WHERE POSTALT.idregistro=%d",$codigo));	
	//si es vacio, se sabe por la documentacion de las tablas que es calle el tipo de via.
	if(!empty($codigo) && $query==null && is_numeric($codigo)){
		$query = "CALLE";
	}
	
	return $query;
}
function calles_correos_devolver_datos_registro($codigo){	
	$sql = "SELECT POSTALT.codvia, POSTALT.viapobla, POSTALT.codigo_postal, CODCIU.descripcion FROM {POSTALT} ".
			"LEFT OUTER JOIN {CODCIU} ON POSTALT.codlocalidad = CODCIU.codlocalidad ". 
			"WHERE POSTALT.idregistro=%d";	
	$result = db_query($sql, $codigo);
	$datos = array();
	while ($data = db_fetch_array($result)){
		$datos['localidad'] = $data['descripcion'];
		$datos['codigo_postal'] = $data['codigo_postal'];
		$datos['calle'] = $data['viapobla'];	
		$datos['tipovia'] = $data['codvia'];
		if(is_null($data['codvia'])||empty($data['codvia']))$datos['tipovia'] = 'CL';
	}
	return $datos;
}

function calles_correos_devolver_via_codigo_registro($codigo){
	
	$query = db_result(db_query("SELECT viapobla FROM {POSTALT} ".
								 "WHERE POSTALT.idregistro=%d", $codigo));
	return $query;
}

function calles_correos_devolver_codigo_postal($codigo){
	
	$query = db_result(db_query("SELECT codigo_postal FROM {POSTALT} ".
								"WHERE POSTALT.idregistro=%d", $codigo));
	return $query;
}
function calles_correos_devolver_poblacion($codigo){

	$query = db_result(db_query("SELECT CODCIU.descripcion FROM POSTALT,CODCIU where ".
	                            "POSTALT.codlocalidad = CODCIU.codlocalidad and POSTALT.idregistro = %d",$codigo));		
	return $query;
}

function calles_correos_autocomplete($string = '', $provincia){
	 $inicioi = microtime(true);
	 $totalLongitudMostrar = 60;
	 $totalCombinacionesPalabra = 100;
     //elimino espacios en blanco del final del string
     $string = rtrim($string);
     //convertir toda la cadena a mayusculas 
     $string = mb_strtoupper($string); //para que no haya problemas como con el strtoupper al pasar a mayusculas con la letra ñ.
     //eliminar tildes
     $cad = calles_correos_eliminar_tildes($string);
     //a la hora de hacer la comparación para autocompletar es donde tendré que ver si ha encontrado alguna cadena
     //igual a lo intruducido. Si no, entonces hacemos las posibles búsquedas por los patrones. 
    
     //quito dobles espacios en blanco
     $cad = quitarDobleEspacioBlanco($cad); 
      //todo a mayusculas y sin tildes.
     $matches1 = busquedaExacta($cad);
     //guardo en $arrayId todos los Id's que hemos encontrado en la primera búsqueda.
     //teniendo en cuenta que $matches1, es un array cuyos índices son las claves
     $arrayId = array_keys($matches1);
     //tamaño del array tras realizar la primera busqueda
     $longitud = sizeof($matches1);
	//variable booleana que me indica si estamos tratando con la ultima pabra 2
     $ultimaPalabra = false;
     //si despues de la primera busqueda no hemos encontrado el minimo de registros necesarios,
	 //seguimos buscando.
	 //verifico si es solo una palabra o no. De forma que, 
	 // como "cad" devuelve cadenas donde encuentre esa cadena de forma seguida en cualquier parte, 
	 //si solo es una palabra, lo que no haya encontrado en la primera búsqueda no lo va a encontrar en la segunda
	 $array_cambios = array();
     if($longitud<$totalLongitudMostrar){
     	
		 //CONSTRUCCION CADENA LIKE
		 $cadena1 = $cad; 
		 $array_posiciones = array();
		 $array_posiciones[] = array('NB','MB','NV','MV');
		 $array_posiciones[] = array ('NP','MP');
		 $array_posiciones[] = array('TX','TZ','CH');
		 $array_posiciones[] = array('GU','G','X','J');
		 $array_posiciones[] = array('RR','R');
		 $array_posiciones[] = array('V','B');
		 $array_posiciones[] = array('LL','Y','I');
		 $array_posiciones[] = array('C','K','QU');
		 $array_posiciones[] = array('N','Ñ');
 	 
		 $array_sustituciones = array(); //array donde tendremos por cada clave, la posicion donde se encuentra en $array_posiciones
		
		 $tiempo1 = microtime(true);
		 foreach($array_posiciones as $key => $value){
		 	foreach($value as $key2 => $value2){
		 		$array_sustituciones[$value2] = $key;
		 	}
		 }
		 $tiempo2 = microtime(true);
		 $tiempo3 = $tiempo2-$tiempo1;
		 
		 //array de palabras <3 para excluir de la busqueda. Como voy a tratar las palabras de forma individual,
		 //quito las combinaciones de el, de la, de los, de las, porque será formada por esas individualmente
		 $opcionales = array('EL','LA','LOS','LAS','EN','UN','DE','DEL','Y');
		
		 //Guardo en un array ,la calle introducida por teclado. Teniendo en cada posicion del array, una palabra.
		 //Teniendo en cuenta que se separa por el espacio en blanco.
		 $array_separar = explode(" ", $cadena1);
		 $longArraySeparar = sizeof($array_separar);
		 //recorro el array por palabras
		 for($i = 0; $i<$longArraySeparar;$i++){
		 	//por cada palabra introducida, ver si hay alguna letra a sustituir.
		 	$palabra = $array_separar[$i];
		 	$longPalabra = mb_strlen($palabra);
		
		 	
		    if(($i+1 === $longArraySeparar)) $ultimaPalabra = true;
		
 			//si es >2 y no es el final y no está en la lista de opcionales
 		    if($longPalabra>2 && !in_array($palabra,$opcionales) || ($longPalabra<=3 && $ultimaPalabra===true)){
 				$cadenaBusqueda = $cadenaBusqueda.' +(>';
				//guardo la primera palabra en el array
				$array_cambios[] = $palabra;
 				
 				foreach($array_sustituciones as $key => $value){
					$pos = strpos($palabra,$key);
		 			if($pos!==FALSE)
		 				$array_combinaciones[$key] = $value;
     	 		}//end foreach		 	
			//$array_combinaciones a cambiar
				if(sizeof($array_combinaciones)>0){
				//recorro $array_combinaciones para ver en $palabra cuantlas letras hay de cada $key
				//repeticiones de $key en palabra
			
				//metodo que devuelve el array $numero iguales, con las posiciones [0] y[1] rellenas
				/**
				 * $numeroIguales[key][0] = numero de veces que aparece
				 * $numeroiguales[key][1] = por lo que lo sustituimos
				 * $numeroIguales[key][2] = las posiciones donde aparece;
				 * */
					$tiempoNumVeces1 = microtime(true);
					$numeroIguales = array();
		    		calculoNumeroVeces($palabra,$array_combinaciones,$array_sustituciones,$numeroIguales);
					$tiempoNumVeces2 = microtime(true);
					$tiempoNumVeces3 = $tiempoNumVeces2-$tiempoNumVeces1;
					//guardo las posiciones donde aparece cada letra.
					//nuevo
				/**
				 * $numeroIguales[key][0] = numero de veces que aparece
				 * $numeroiguales[key][1] = por lo que lo sustituimos
				 * $numeroIguales[key][2] = las posiciones donde aparece;
				 * */ 
					$inicioPosiciones = microtime(true);
					calculoPosiciones($numeroIguales,$palabra,$array_sustituciones); //paso por referencia $numeroIguales y $array_sustituciones
					$finalPosiciones = microtime(true);
					$totalPosiciones = $finalPosiciones-$inicioPosiciones;
					//obtengo el numero de valores de cada posicion del array de combinaciones
					$combinar = array();
			
					$tiempoNumCombinaciones = microtime(true);
					$numeroCombinaciones = 1;
					//en combinar guardo las posibilidades que hay en cada
					foreach($numeroIguales as $clave => $valor){
						$cantidad = count($array_posiciones[$array_combinaciones[$clave]]);
						$numeroCombinaciones *= pow($cantidad,$valor[0]);
						$cantidad--;
					
						for($numeroVeces=0;$numeroVeces<$valor[0];$numeroVeces++){
							$combinar[] = $cantidad; 
						}
					}
					//calcula el numero de combinaciones total, por cada palabra.
					$tiempoNumCombinaciones2 = microtime(true);
					$tiempoNumCombinaciones3 = $tiempoNumCombinaciones2-$tiempoNumCombinaciones;

					if($numeroCombinaciones<$totalCombinacionesPalabra){
					//$array_comb contendrá todas las combinaciones de la palabra con los patrones.
					//hacemos combinaciones si la palabra es >2 
					$array_comb=combinaciones($combinar);
			    	$tiempoTodasCombinaciones = microtime(true);
					foreach($array_comb as $keyArrayComb => $valorArrayComb){
						$tiempoSustituciones = microtime(true);
						//separo por la coma la cadena para luego buscar en array de combinaciones la posicion que necesito
				   		$array2 = explode('|' , $valorArrayComb);
				 		$j2 = 0;
				 		$reemplazo = array();
				   		foreach($array_combinaciones as $key  => $value){ //$array_combinaciones
				   		
				   			$total = $numeroIguales[$key][0]; //añado  			
				   			for($totalpos = 0;$totalpos<$total;$totalpos++){//añado
				   				$reemplazo[$key][] =$array_posiciones[$value][$array2[$j2]];  //[$array_combinaciones[$key]][$array2[$j2]
				   				$j2++;
				   			}
				   			
				   		}
						$tiempoSustituciones2 = microtime(true);
						$tiempoSustituciones3 = $tiempoSustituciones2-$tiempoSustituciones;			   		
				   	//en $reemplazo ya tengo según la clave, el valor a sustituir.
				   		$cadenaSustitucion  = $palabra;
				   
				  		$var_anterior = 0;		   	
				   		foreach($numeroIguales as $clave => $valor){
				   			$posicion = 0;
				   		
				   	  	 //$valor[2] array donde están las posiciones donde aparece la clave en $palabra
							foreach($valor[2] as $claveArrayPosiPalabra => $valueArrayPosiPalabra){
								$caracter= $reemplazo[$clave][$posicion]; //caracter a sustituir
							 	$longitud = mb_strlen($caracter);
							 	$longitudClave = mb_strlen($clave);
							 	$start = $valueArrayPosiPalabra+$var_anterior;	
				   				//ver si sustituyo dos letras por dos letras, o una letra por dos letras.
				   				//si es una letra por dos letras, tenemos un problema
				   				$cadenaSustitucion = mb_substr_replace($cadenaSustitucion, $caracter, $start,$longitudClave);
				   				$var_anterior = $longitud-$longitudClave;
				   				$posicion++;
							}
				  	 	}
					//cuando termino todos los cambios sobre la palabra, la voy guardando en mi array de cambios.
				   	//para evitar que haya duplicados
				//sensible a mayusculas y minusculas, pero como está en mayusculas, no problema.
					if(!in_array($cadenaSustitucion,$array_cambios))
				   		//verifico que la combinacion que venga, no esté ya en el array de cambios.
				   			$array_cambios[] = $cadenaSustitucion;
					
				   	//ya hemos guardado esa palabra, ahora ya las posiciones ocupadas de la anterior palabra no nos interesan
					unset($posicionesOcupadas);
				}	
				
			
			    $delimitador = $ultimaPalabra?"* ":" ";
				$cadenaBusqueda.= implode($delimitador,$array_cambios);
						
			}//endif $numeroCombinaciones<$totalCombinacionesPalabra
			
				$cadenaBusqueda .= $ultimaPalabra?"*)":") ";
							
				//vacío el array_combinaciones para guardar solo las combinaciones de lo que necesito de la siguiente palabra-.
				unset($array_combinaciones);
				unset($array_cambios);
				unset($combinar);
				unset($numeroIguales);
					
		}//end if sizeof($array_combinaciones)
		else{
			if(strlen($palabra)>=2)
				if($ultimaPalabra === true)
					$cadenaBusqueda = $cadenaBusqueda.$palabra. '*) ';
			}
		 }//endif
	}
		 $tiempoTodasCombinaciones2 = microtime(true);
		
		//BUSCAMOS EN LA BBDD CON LIKE Y CON REGEXP
		 $inicioConsulta = microtime(true);
		 $matches2 = calles_correos_busqueda_coincidencias($cadenaBusqueda,$provincia,$arrayId);
		 $finalConsulta = microtime(true);
          //ORDENAMOS EL ARRAY CON LAS COMPARACIONES ENCONTRADAS.
    	 if(sizeof($matches1)>0 && sizeof($matches2)>0)
    	 //unifico las dos busquedas encontradas
    	 	$matches = array_merge ($matches1,$matches2);
    	 else if(sizeof($matches1)<1){
    	 	$matches = $matches2;
    	 }
    	 else if(sizeof($matches2)<1) 
    	 	$matches = $matches1;
	 	}
	 	//si busquedaExacta ya devuelve el maximo de registros permitidos ;
	 	//Entonces $matches contendrá el array $matches1 que es el que devolvió la búsqueda Exacta realizada la primera vez, sobre 
	 	//la palabra introducida.
	 	else {
     		$matches = $matches1;
     	}
     	
     $inicioOrdenacion = microtime(true);	
     $inicioOrdenacionLev = microtime(true);	
	 $copiaordenacion = array();
	 $ordenacion = $matches;
   	 $distancia = -1;
 	//for donde ordeno por la distancia de levenshtein
   	 foreach($ordenacion as $key=>$value){
   		$copiaordenacion[$key] =$ordenacion[$key];
  		ordenar_distancia_lev($cad,levenshtein($cad,$ordenacion[$key]['viapobla']),$key,$copiaordenacion); //copiaordenacion va por referencia &$copiaordenacion.
   	}
	$finalOrdenacionLev = microtime(true);
   	//ordenar por impar-inferior : vias con mismo nombre de calle, ciudad, provincia.
   	$inicioOrdenacionImpar = microtime(true);
   	$copia = array();
   	foreach($copiaordenacion as $k=>$v){
   		foreach($copiaordenacion as $k2=>$v2){
    				//tienen la misma via y la misma ciudad. Ordenamos por impar inferior de menos a mas
			if(($v['viapobla'] === $v2['viapobla']) && ($v['ciudad'] === $v2['ciudad']) && ($v['nimparinf']<=$v2['nimparinf'])){
  				$copia[$k2]=$copiaordenacion[$k2];
				$copiaordenacion[$k2] = $copiaordenacion[$k];
				$copiaordenacion[$k] = $copia[$k2];		
			}//endif 
   		}//end for each
   	}//end foreach
    $finalOrdenacion = microtime(true);	
   	$finalOrdenacionImpar = microtime(true);		
   			
    $finali = microtime(true); //tiempo total
	$totali = $finali-$inicioi;
	//tiempo consulta
	$totalConsulta = $finalConsulta-$inicioConsulta;
	//total ordenar por lev y por impar
	$totalOrdenacion  = $finalOrdenacion - $inicioOrdenacion;
	//Ordenacion Lev
	$totalOrdenacionLev = $finalOrdenacionLev - $inicioOrdenacionLev;
	//Ordenacion por impar
	$totalOrdenacionImpar = $finalOrdenacionImpar - $inicioOrdenacionImpar;
    //tiempo en hacer todas las modificaciones de la palabra
    $tiempoTodasCombinaciones3 = $tiempoTodasCombinaciones2-$tiempoTodasCombinaciones;
       
    $memoria = memory_get_usage();
	// Quitar desde array_devolver hasta drupal_json 
	//descomentar return 
    $array_devolver = array();
   	foreach ($copiaordenacion as $match){
   		
   		$array_devolver[$match['idregistro']] =  		
		  						 '<span class = "muestra_calle"><b>' . $match['tipovia'] . ' ' . '</b></span>' .
		  												  '<span class = "muestra_viapobla">'  . $match['viapobla'] . ' ' . '</span>' .
   		  												  '<span class = "muestra_nimparinf">'	. $match['nimparinf'] . '-' . '</span>'.
   														  '<span class = "muestra_nimparsup">' . $match['nimparsup'] . ' ' . '</span>'.
   														  '<span class = "muestra_nparinf">' . $match['nparinf']. '-' . '</span>'.
   														  '<span class = "muestra_nparsup">' . $match['nparsup'] . ' ' . '</span>'.
		  												  '<span class = "muestra_cp">'. $match['codigo_postal']  . ' ' . '</span>' .
		  												  '<span class = "muestra_descripcion">' . $match['ciudad'] . ' ' . '</span>';
			
	}//end foreach
	
    drupal_json($array_devolver);
   // return $copiaordenacion;
  
}

function calculoNumeroVeces($palabra,&$array_combinaciones,&$array_sustituciones,&$numeroIguales){
		foreach($array_combinaciones as $clave => $valor){
			//Una vez que ya tengo mi $array_combinaciones con todas las claves posibles, 
			// miro en el array_posiciones todas las posibles combinaciones para buscarlos en la palabra 
			//y ver cuántas hay de cada una. 
			//obtengo el array correspondiente a la clave
			/**
			 * $numeroIguales[key][0] = numero de veces que aparece
			 * $numeroiguales[key][1] = por lo que lo sustituimos
			 * $numeroIguales[key][2] = las posiciones donde aparece;
			 * */
			$numeroIguales[$clave] = array(substr_count($palabra,$clave),$array_sustituciones[$clave]); 
				//$numero iguales contendrá por cada clave el numero de veces que aparece repetido.	
		}//end foreach
}

function calculoPosiciones(&$numeroIguales,$palabra,&$array_sustituciones){
	$posOcupadas = array();//añado jueves a ultima hora
	foreach($numeroIguales as $clave => $valor){ 
		$posInicial = 0;
		$posi = 0;
		$posiciones = array();
		$longitudClave = mb_strlen($clave);
		
		while(($posAparicion= mb_strpos($palabra,$clave,$posInicial))!== FALSE){
			//caso que sea RR
			//este if es para las claves, que pueden formar parte de otra clave, para que no cuente las posiciones dos veces, y por tanto, 
			//no cree combinaciones innecesarias. 
			
			//compruebo que no este ocupada esa posicion 
			if( $posOcupadas[$posAparicion]!==1){
				//si no está ocupada, según la longitud de la clave, ocupo una o dos posiciones.
				$posOcupadas[$posAparicion] = 1; //caso de longitud clave uno
				if($longitudClave===2){
					$posOcupadas[$posAparicion+1] = 1; //caso de longitud clave 2;
				}
				$posiciones[$posi] = $posAparicion; //guardo la posicion donde aparece la clave.
		 	 	$posi++;
				
			}
			$posInicial = $posAparicion+$longitudClave;//1;
	
		} //end while
		if(count($posiciones)>0){ //existe en al menos una posicion de la palabra
			$numeroIguales[$clave][0] = count($posiciones); //actualizo con el numero real de veces que aparece
			$numeroIguales[$clave][2] = $posiciones;
		}
		else //sino,no me interesa. Elimino esa clave, para que no cree combinaciones innecesarias
			unset($numeroIguales[$clave]);
	}
}


function mb_substr_replace($string, $replacement, $start, $length = null, $encoding = null)
    {
        if (extension_loaded('mbstring'))
        {
            $string_length = (is_null($encoding)) ? mb_strlen($string) : mb_strlen($string, $encoding);
           
            if ($start < 0){
                $start = max(0, $string_length + $start);
            }
           
            else if ($start > $string_length){
                $start = $string_length;
            }
           /////*****************
            if ($length < 0){
                $length = max(0, $string_length - $start + $length);
            }
           
            else if ((is_null($length)) || ($length > $string_length)){
                $length = $string_length;
            }
           
            if (($start + $length) > $string_length){
                $length = $string_length - $start;
            }
           
            if (is_null($encoding)){
                return mb_substr($string, 0, $start) . $replacement . mb_substr($string, $start + $length, $string_length - $start - $length);
            }
           
            return mb_substr($string, 0, $start, $encoding) . $replacement . mb_substr($string, $start + $length, $string_length - $start - $length, $encoding);
        }
       
        return (is_null($length)) ? substr_replace($string, $replacement, $start) : substr_replace($string, $replacement, $start, $length);
    }

function combinaciones($combinar){

  $posibilidades = array();
  //estamos en el caso base.
  if ( count($combinar) == 1){
    do{
     $posibilidades[] = $combinar[0]; 
 	 }while($combinar[0]--);
 	 return $posibilidades;
  }
  else{
    $combin_resto = combinaciones(array_slice($combinar,1));
    $size = sizeOf($combin_resto) -1;
    do{
      $i = $size;
     	do{
  		 $posibilidades[] =  $combinar[0].'|'.$combin_resto[$i];  
  	 	}while($i--);
  	 }while($combinar[0]--);
  	}
  return $posibilidades;
}


function calles_correos_busqueda_coincidencias($cadenaBusqueda,$provincia,$arrayId){
	
	 $matches = array();
	 $cadena = "(".implode($arrayId,',').")";
	 $sqlInicial = "SELECT CODVIA.descvia,viapobla,idregistro,codigo_postal,CODCIU.descripcion,".
  				   "num_impar_inferior,num_impar_superior,num_par_inferior,num_par_superior FROM {POSTALT}".
  				   " LEFT OUTER JOIN {CODCIU} ON POSTALT.codlocalidad = CODCIU.codlocalidad ".
  				   "LEFT OUTER JOIN {CODVIA} ON POSTALT.codvia = CODVIA.codvia  WHERE";
	//la busqueda inicial no ha devuelto nada. Posibles errores gramaticales.	
		if(empty($provincia)){
			
			if(!empty($arrayId)){

  				$sql = $sqlInicial." idregistro NOT IN $cadena AND ".
  				       "(MATCH(viapobla) AGAINST('%s' IN BOOLEAN MODE)) ".
  				       "ORDER BY (MATCH(viapobla) AGAINST('%s' IN BOOLEAN MODE)) DESC";
  				//$cad tiene algo de la forma +isabel +la +catolica
  				$result = db_query_range($sql,array($cadenaBusqueda,$cadenaBusqueda), 0, 40);
			}
			else{
				$sql = $sqlInicial." (MATCH(viapobla) AGAINST('%s' IN BOOLEAN MODE)) ".
					   "ORDER BY (MATCH(viapobla) AGAINST('%s' IN BOOLEAN MODE)) DESC";
  				//$cad tiene algo de la forma +isabel +la +catolica
  				$result = db_query_range($sql,array($cadenaBusqueda,$cadenaBusqueda), 0, 40);
			}
  		
		}
		else {
	
			if(!empty($arrayId)){
		
				$sql = $sqlInicial." idregistro NOT IN $cadena AND CODCIU.descripcion='%s' and ".
  					   "(MATCH(viapobla) AGAINST('%s' IN BOOLEAN MODE)) ".
  				       "ORDER BY (MATCH(viapobla) AGAINST('%s' IN BOOLEAN MODE)) DESC";
 				$result = db_query_range($sql,array($provincia,$cadenaBusqueda,$cadenaBusqueda), 0, 40);
			}
			else {
				$sql = $sqlInicial." CODCIU.descripcion='%s' and ".
  				       "(MATCH(viapobla) AGAINST('%s' IN BOOLEAN MODE)) ".
  				       "ORDER BY (MATCH(viapobla) AGAINST('%s' IN BOOLEAN MODE)) DESC";
				$result = db_query_range($sql,array($provincia,$cadenaBusqueda,$cadenaBusqueda), 0, 40);
			}
		
		}
    	 // only 15 results will show
    		while ($calleCorreos = db_fetch_object($result)) {
    			//calle por defecto es vacío (viene en las hojas de comentarios de la bbdd
    			if($calleCorreos->descvia==null){
					$calle = "CALLE";
				}
				else{
					$calle = $calleCorreos->descvia;
				}
		  		$matches[$calleCorreos->idregistro] = array("tipovia" => $calle, 
		  		 				                      "viapobla" => $calleCorreos->viapobla,
		  		 				                      "idregistro" => $calleCorreos->idregistro,
		  		 			                          "codigo_postal" => $calleCorreos->codigo_postal,
		  		 				                      "ciudad" => $calleCorreos->descripcion,
		  						                      "nimparinf" => $calleCorreos->num_impar_inferior,
		  						                      "nimparsup" => $calleCorreos->num_impar_superior,
		  						                      "nparinf" => $calleCorreos->num_par_inferior,
		  						                      "nparsup" => $calleCorreos-> num_par_superior);  		
		    } //end while

	return $matches;
	
}

function busquedaExacta($cad){
	//tenemos que poner la $cad de manera que en la primera búsqueda encuentre la cadena tal cual, por tanto, utilizo 
	//". Luego ya buscaré que contenga la palabra en cualquier punto. 
	
	$cad2 = $cad.'%';
	$cad3 = '"'.$cad.'"';
	$sql = "SELECT CODVIA.descvia,viapobla,idregistro,codigo_postal,CODCIU.descripcion,".
  		   "num_impar_inferior,num_impar_superior,num_par_inferior,num_par_superior FROM {POSTALT} ".
  	       "LEFT OUTER JOIN {CODCIU} ON POSTALT.codlocalidad = CODCIU.codlocalidad ".
  		   "LEFT OUTER JOIN {CODVIA} ON POSTALT.codvia = CODVIA.codvia WHERE ".
		   "viapobla like '%s' ". 
		   "ORDER BY viapobla ASC";
		   $result  = db_query_range($sql,$cad2,0,60);
     while ($calleCorreos = db_fetch_object($result)) {
    			//calle por defecto es vacío (viene en las hojas de comentarios de la bbdd
    			if($calleCorreos->descvia==null){
					$calle = "CALLE";
				}
				else{
					$calle = $calleCorreos->descvia;
				}
		  		$matches[$calleCorreos->idregistro] = array("tipovia" => $calle, 
		  		 				                      "viapobla" => $calleCorreos->viapobla,
		  		 				                      "idregistro" => $calleCorreos->idregistro,
		  		 			                          "codigo_postal" => $calleCorreos->codigo_postal,
		  		 				                      "ciudad" => $calleCorreos->descripcion,
		  						                      "nimparinf" => $calleCorreos->num_impar_inferior,
		  						                      "nimparsup" => $calleCorreos->num_impar_superior,
		  						                      "nparinf" => $calleCorreos->num_par_inferior,
		  						                      "nparsup" => $calleCorreos-> num_par_superior);  		
    } //end while

	return $matches;
     
}


function quitarDobleEspacioBlanco($cadena){
	$cadcopia = $cadena;
	while(strpos($cadcopia,'  ')!==FALSE){
		$cadcopia = str_replace('  ',' ',$cadcopia);
	}
	return $cadcopia;
}
//ordenacion distancia de lev 
function ordenar_distancia_lev($cad,$distancia,$key,&$copiaordenacion){
	$copia = array();
   	foreach($copiaordenacion as $key2 =>$value2){
   		//saco la via pobla
   		//cuanto de iguales son $cad(introducida) y la encontrada
   		//$lev = levenshtein($cad,$copiaordenacion[$key2]['viapobla']);
   		if(levenshtein($cad,$copiaordenacion[$key2]['viapobla'])>$distancia){
   			$copia[$key2]=$copiaordenacion[$key2];
   			$copiaordenacion[$key2]=$copiaordenacion[$key];
   		  	$copiaordenacion[$key] = $copia[$key2];
   		}	
	
   	}
}

//ELIMINAR TILDES PALABRA ORIGINAL CASTELLANAS, CATALANAS Y DIERESIS
function calles_correos_eliminar_tildes($string){
	
	$cadena1 = $string;
	$patrones = array();
		$patrones[] = '/(Á|À|Ä)/';
		$patrones[] = '/(É|È|Ë)/';
		$patrones[] = '/(Í|Ì|Ï)/';
		$patrones[] = '/(Ó|Ò|Ö)/';
		$patrones[] = '/(Ú|Ù|Ü)/';
	$sustituciones = array();
		$sustituciones[] = 'A';
		$sustituciones[] = 'E';
		$sustituciones[] = 'I';
		$sustituciones[] = 'O';
		$sustituciones[] = 'U';
	$cadena = preg_replace ($patrones, $sustituciones,$cadena1);
	return $cadena;
}



