<?php

function calles_correos_existe_registro_id($id){
	$sql = "SELECT idregistro FROM {POSTALT} WHERE idregistro = %d";
	$result = db_result(db_query($sql,$id));
	if($result !== false)$result = TRUE;
	return $result;
}


function calles_correos_devolver_tipo_via($codigo){
	
	$query = db_result(db_query("SELECT CODVIA.descvia FROM {POSTALT} ".
							"LEFT OUTER JOIN {CODVIA} ON POSTALT.codvia = CODVIA.codvia ".
							"WHERE POSTALT.idregistro=%d",$codigo));	
	//si es vacio, se sabe por la documentacion de las tablas que es calle el tipo de via.
	if(!empty($codigo) && $query==null && is_numeric($codigo)){
		$query = "CALLE";
	}
	
	return $query;
}
function calles_correos_devolver_datos_registro($codigo){	
	$sql = "SELECT POSTALT.codvia, POSTALT.viapobla, POSTALT.codigo_postal, CODCIU.descripcion FROM {POSTALT} ".
			"LEFT OUTER JOIN {CODCIU} ON POSTALT.codlocalidad = CODCIU.codlocalidad ". 
			"WHERE POSTALT.idregistro=%d";	
	$result = db_query($sql, $codigo);
	$datos = array();
	while ($data = db_fetch_array($result)){
		$datos['localidad'] = $data['descripcion'];
		$datos['codigo_postal'] = $data['codigo_postal'];
		$datos['calle'] = $data['viapobla'];	
		$datos['tipovia'] = $data['codvia'];
		if(is_null($data['codvia'])||empty($data['codvia']))$datos['tipovia'] = 'CL';
	}
	return $datos;
}

function calles_correos_devolver_via_codigo_registro($codigo){
	
	$query = db_result(db_query("SELECT viapobla FROM {POSTALT} ".
								 "WHERE POSTALT.idregistro=%d", $codigo));
	return $query;
}

function calles_correos_devolver_codigo_postal($codigo){
	
	$query = db_result(db_query("SELECT codigo_postal FROM {POSTALT} ".
								"WHERE POSTALT.idregistro=%d", $codigo));
	return $query;
}
function calles_correos_devolver_poblacion($codigo){

	//sql antigua cuando teniamos las dos tablas de codmun y codciu
	
	/**$sql = "SELECT if( POSTALT.cmun =0, (SELECT descripcion FROM CODCIU WHERE CODCIU.codlocalidad = POSTALT.codlocalidad), ("
		."SELECT descripcion FROM CODMUN WHERE CODMUN.cpro = POSTALT.cpro AND CODMUN.cmun = POSTALT.cmun) ) AS nombrePoblacion FROM POSTALT "
		."WHERE POSTALT.idregistro = '%s'";		
		$query = db_result(db_query($sql,$codigo));*/
	$query = db_result(db_query("SELECT CODCIU.descripcion FROM POSTALT,CODCIU where POSTALT.codlocalidad = CODCIU.codlocalidad and POSTALT.idregistro = %s",$codigo));	

		
	return $query;
	
}

function calles_correos_autocomplete($string = '', $provincia){
	 $inicioi = microtime(true);
	 
	 $totalLongitudMostrar = 60;
	 $totalCombinacionesPalabra = 100;
     //elimino espacios en blanco del final del string
     $string = rtrim($string);
     //convertir toda la cadena a mayusculas 
     $string = mb_strtoupper($string); //para que no haya problemas como con el strtoupper al pasar a mayusculas con la letra ñ.
     //eliminar tildes
     $cad = calles_correos_eliminar_tildes($string);
     //a la hora de hacer la comparación para autocompletar es donde tendré que ver si ha encontrado alguna cadena
     //igual a lo intruducido. Si no, entonces hacemos las posibles búsquedas por los patrones. 
    
     //quito dobles espacios en blanco
     $cadc = $cad;
     $cad = quitarDobleEspacioBlanco($cadc); //cadc
      //todo a mayusculas y sin tildes.
     $matches1 = busquedaExacta($cad);//cadc//$matches1=busquedaExacta($cad.'%');
     //guardo en $arrayId todos los Id's que hemos encontrado en la primera búsqueda.
     //teniendo en cuenta que $matches1, es un array cuyos índices son las claves
     $arrayId = array_keys($matches1);
     //tamaño del array tras realizar la primera busqueda
     $longitud = sizeof($matches1);
	//variable booleana que me indica si estamos tratando con la ultima pabra 2
     $ultimaPalabra = false;
     //si despues de la primera busqueda no hemos encontrado el minimo de registros necesarios,
	 //seguimos buscando.
	 //verifico si es solo una palabra o no. De forma que, 
	 // como "cad" devuelve cadenas donde encuentre esa cadena de forma seguida en cualquier parte, 
	 //si solo es una palabra, lo que no haya encontrado en la primera búsqueda no lo va a encontrar en la segunda

     if($longitud<$totalLongitudMostrar){
     	
		 //CONSTRUCCION CADENA LIKE
		 $cadena1 = $cad; //$string
		 $array_posiciones = array();
		 $array_posiciones[0] = array('NB','MB','NV','MV');
		 $array_posiciones[1] = array ('NP','MP');
		 $array_posiciones[2] = array('TX','TZ','CH');
		 $array_posiciones[3] = array('GU','G','X','J');
		 $array_posiciones[4] = array('RR','R');
		 $array_posiciones[5] = array('V','B');
		 $array_posiciones[6] = array('LL','Y','I');
		 $array_posiciones[7] = array('C','K','QU');
		 $array_posiciones[8] = array('N','Ñ');
 	 
		 $array_sustituciones = array();
		
			//antiguo
		/* for($indice = 0;$indice<sizeof($array_posiciones);$indice++){
		 	 $key = $array_posiciones[$indice];
		 	 for($ind2 = 0;$ind2<sizeof($key);$ind2++){
		 	        $k = $key[$ind2];
					$array_sustituciones[$k] = $indice;	//creo arrays de la forma $array_sustituciones['NB']  = $array_posiciones[0]; etc;
		 	 }		 
		 }*/
		 	
		 $tiempo1 = microtime(true);
		 foreach($array_posiciones as $key => $value){
		 	foreach($value as $key2 => $value2){
		 		$array_sustituciones[$value2] = $key;
		 	}
		 }
		 $tiempo2 = microtime(true);
		 $tiempo3 = $tiempo2-$tiempo1;
		 
		 //array de palabras <3 para excluir de la busqueda. Como voy a tratar las palabras de forma individual,
		 //quito las combinaciones de el, de la, de los, de las, porque será formada por esas individualmente
		// $opcionales = array('EL','LA','LOS','LAS','EN','UN','DE','DEL','Y'); //,'Y','DE EL','DE LA','DE LOS','DE LAS'
		
		 //Guardo en un array ,la calle introducida por teclado. Teniendo en cada posicion del array, una palabra.
		 //Teniendo en cuenta que se separa por el espacio en blanco.
		 $array_separar = explode(" ", $cadena1);
		 //$k = 0; //indice del array donde guardaré las palabras 
		 //primero recorro el array por palabras
		// $comb = 0;
		// $numero = 0;
		
		 $longArraySeparar = sizeof($array_separar);
		 for($i = 0; $i<$longArraySeparar;$i++){
		 	//por cada palabra introducida, ver si hay alguna letra a sustituir.
		 	$palabra = $array_separar[$i];
		 	$longPalabra = mb_strlen($palabra);
		 	$aux = $i;
		 	$timeWhile = microtime(true);
		 	while($longPalabra<=3 && (($aux+1 !== $longArraySeparar))){
		 		//ahora directamente me da igual que esté en el array de $opcionales o no..
		 		//por lo tanto , si es una palabra inferior a tres caracteres y no es la ultima palabra, la omitimos y pasamos
		 		$i++; 
		 		$palabra = $array_separar[$i];
		 		$longPalabra = mb_strlen($palabra);

		 	}//end while
 			$timeWhile2 = microtime(true);
 			$finalWhile = $timeWhile2-$timeWhile;
		 	
			//volvemos a obtener el indice,ya hemos salido del while;
		 	$aux = $i;
		 	if($longPalabra>2 && (($aux+1)!==$longArraySeparar)) //no estamos en la ultima palabra
		 		$cadenaBusqueda = $cadenaBusqueda.' +(>'.$palabra;
		 	
		 	else if(($aux+1)===$longArraySeparar){
		 		$cadenaBusqueda = $cadenaBusqueda.' +(>'.$palabra;
		 		$ultimaPalabra = true;
		 	}
		 	
	 		//ahora compruebo si hay letras del array de sustituciones en cada palabra del array inicial
	 		//$cont = 0;		
		 	foreach($array_sustituciones as $key => $value){
		 		$pos = strpos($palabra,$key);//$array_sustituciones[$key]);
		 		if($pos!==FALSE)
		 			$array_combinaciones[$key] =$array_sustituciones[$key];
     	 	}//end foreach		 	
		//$array_combinaciones a cambiar
		if(sizeof($array_combinaciones)>0){
				//recorro $array_combinaciones para ver en $palabra cuantlas letras hay de cada $key
				//repeticiones de $key en palabra
			
			//metodo que devuelve el array $numero iguales, con las posiciones [0] y[1] rellenas
			/**
				 * $numeroIguales[key][0] = numero de veces que aparece
				 * $numeroiguales[key][1] = por lo que lo sustituimos
				 * $numeroIguales[key][2] = las posiciones donde aparece;
				 * */
			$tiempoNumVeces1 = microtime(true);
			$numeroIguales = calculoNumeroVeces($palabra,$array_combinaciones,$array_sustituciones,$array_posiciones);
			$tiempoNumVeces2 = microtime(true);
			$tiempoNumVeces3 = $tiempoNumVeces2-$tiempoNumVeces1;
			//antiguo
		/*	$iniPosAnt = microtime(true);
			foreach($numeroIguales as $clave => $valor){
				$posi = 0;
				for($recorrer = 0;$recorrer<$longPalabra;$recorrer++){
					if(mb_strlen($clave)===2 && $recorrer+1<$longPalabra)
						$iguales = strcmp($clave,$palabra[$recorrer].$palabra[$recorrer+1]); //**************!!!!!!!
					else
						$iguales = strcmp($clave,$palabra[$recorrer]);
						
					if($iguales==0){
						$posiciones[$posi] = $recorrer; //guardo en la posicion 2, la posicion donde se encuentra esa letra. 
						$posi++;
					}
				}
				$numeroIguales[$clave][2] = $posiciones;
				//una vez ya guardadas las posiciones, lo dejo vacío para la proxima palabra
				unset($posiciones);
			}
			$finPosAnt = microtime(true);
			$totalPosAnt = $finPosAnt-$iniPosAnt;*/
			
			
			//guardo las posiciones donde aparece cada letra.
			//nuevo
				/**
				 * $numeroIguales[key][0] = numero de veces que aparece
				 * $numeroiguales[key][1] = por lo que lo sustituimos
				 * $numeroIguales[key][2] = las posiciones donde aparece;
				 * */ 
			$inicioPosiciones = microtime(true);
			$numeroIguales = calculoPosiciones($numeroIguales,$palabra,$array_sustituciones);
			$finalPosiciones = microtime(true);
			$totalPosiciones = $finalPosiciones-$inicioPosiciones;
			//obtengo el numero de valores de cada posicion del array de combinaciones
			$combinar = array();
			$p = 0;
			$tiempoNumCombinaciones = microtime(true);
			$numeroCombinaciones = 1;
				//en combinar guardo las posibilidades que hay en cada
				foreach($numeroIguales as $clave => $valor){
					for($numeroVeces=0;$numeroVeces<$valor[0];$numeroVeces++){
						$combinar[$p] = count($array_posiciones[$array_combinaciones[$clave]])-1; //$combinar[$p] = count($array_combinaciones[$key])-1
						$p++;	
						$numeroCombinaciones = count($array_posiciones[$array_combinaciones[$clave]]) * $numeroCombinaciones;
					}
				}
				//calcula el numero de combinaciones total, por cada palabra.
				$tiempoNumCombinaciones2 = microtime(true);
				$tiempoNumCombinaciones3 = $tiempoNumCombinaciones2-$tiempoNumCombinaciones;

			if($numeroCombinaciones<$totalCombinacionesPalabra){
				//$array_comb contendrá todas las combinaciones de la palabra con los patrones.
				//hacemos combinaciones si la palabra es >2 
				$array_comb=combinaciones($combinar);
			    $comb = 0;
			    $tiempoTodasCombinaciones = microtime(true);
				foreach($array_comb as $keyArrayComb => $valorArrayComb){
					$tiempoSustituciones = microtime(true);
					//separo por la coma la cadena para luego buscar en array de combinaciones la posicion que necesito
				   	$array2 = explode('|' , $valorArrayComb);
				 	$j2 = 0;
				   		foreach($array_combinaciones as $key  => $value){ //$array_combinaciones
				   			$sustituciones = array();
				   			$j = 0;
				   			$total = $numeroIguales[$key][0]; //añado  			
				   			for($totalpos = 0;$totalpos<$total;$totalpos++){//añado
				   				$sustituciones[$j] =$array_posiciones[$value][$array2[$j2]];  //[$array_combinaciones[$key]][$array2[$j2]
				   				$j++;
				   				$j2++;
				   			}
				   			$reemplazo[$key] = $sustituciones;
				   		}
					$tiempoSustituciones2 = microtime(true);
					$tiempoSustituciones3 = $tiempoSustituciones2-$tiempoSustituciones;			   		
				   	//en $reemplazo ya tengo según la clave, el valor a sustituir.
				   	$cadenaSustitucion  = $palabra;
				   	$cuantosAumenta=0;
				   	$cuantosDisminuye = 0;
				   	$aumenta =false;
				   	$disminuye=false;
				  					   	
				   	foreach($numeroIguales as $clave => $valor){
				   		$posicion = 0;
				   		//$arrayPosiPalabra = $valor[2]; //array donde están las posiciones donde aparece la clave en $palabra //$numeroIguales[$clave] -> $valor
						foreach($valor[2] as $claveArrayPosiPalabra => $valueArrayPosiPalabra){
							 $caracter= $reemplazo[$clave][$posicion]; //caracter a sustituir
							 $longitud = mb_strlen($caracter);
							 $longitudClave = mb_strlen($clave);
							 $start = $valueArrayPosiPalabra;	
				   				//ver si sustituyo dos letras por dos letras, o una letra por dos letras.
				   				//si es una letra por dos letras, tenemos un problema
				   				if($longitudClave===1 && $longitud===2){
				   					if($aumenta===TRUE && $valueArrayPosiPalabra>$cambio){
			   							$start = $valueArrayPosiPalabra+$cuantosAumenta;
				   					}
				   					//ha disminuirdo la palabra en alguna palabra
				   					else if($disminuye === TRUE) //$valueArrayPosiPalabra>$cambio
				   						$start = $valueArrayPosiPalabra-$cuantosDisminuye;	
				   					//else //la posicion a cambiar es inferior a la posicion donde se ha aumentado o disminuido.
				   						//$start = $valueArrayPosiPalabra;	
				   						
				   					$cadenaSustitucion = mb_substr_replace($cadenaSustitucion,$caracter,$start,1);
				   					//longitud palabra aumenta en uno
				   					$aumenta = true;
				   					$cuantosAumenta++;
				   					$cambio=$valueArrayPosiPalabra;
				   			
				   				} 
				   				else if($longitudClave===2 && $longitud===1){
				   					if($disminuye ===TRUE && $valueArrayPosiPalabra>$cambioDisminuye)
										 //if($valueArrayPosiPalabra>$cambioDisminuye)
									   $start = $valueArrayPosiPalabra-$cuantosDisminuye; //$long
									else if($aumenta === TRUE && $valueArrayPosiPalabra>$posCambio)
										$start = $valueArrayPosiPalabra+$cuantosAumenta;	

								
									$cadenaSustitucion = mb_substr_replace($cadenaSustitucion,$caracter,$start,2);	

				   					//problema inverso..
									//al sustituir dos caracteres por uno, la cadena disminuye en longitud.
									$cuantosDisminuye = $cuantosDisminuye+1;	
									$disminuye = true;		   				
				   					$cambioDisminuye = $valueArrayPosiPalabra;
				   				}
				   				else{
				   					//similar si la clave y el valor a cambiar son ambas de longitud dos o dde longitud uno.
				   					if($aumenta === TRUE && $disminuye === FALSE){
				   						if($valueArrayPosiPalabra>$cambio)
				   							$start = $valueArrayPosiPalabra+$cuantosAumenta;
				   						//else $start = $valueArrayPosiPalabra;
				   							
				   						$cadenaSustitucion = mb_substr_replace($cadenaSustitucion,$caracter,$start,$longitud);
				   						/*}
				   						else{
				   							$cadenaSustitucion = mb_substr_replace($cadenaSustitucion, $caracter,$valueArrayPosiPalabra,$longitud);
				   						}*/
				   					}
				   					else if ($disminuye === TRUE && $aumenta === FALSE){
				   						 if($valueArrayPosiPalabra>$cambioDisminuye)
				   						 	$start = $valueArrayPosiPalabra-$cuantosDisminuye;
				   						// else 
				   						 	//$start = $valueArrayPosiPalabra;
				   						
				   						 $cadenaSustitucion = mb_substr_replace($cadenaSustitucion, $caracter,$start,$longitud);
				   					}
				   					else if($aumenta === TRUE && $disminuye === TRUE){
				   						$long = $valueArrayPosiPalabra+$cuantosAumenta;
				   						if($long>0)
				   							$long = $long-$cuantosDisminuye;
				   						
				   						$cadenaSustitucion = mb_substr_replace($cadenaSustitucion, $caracter, $long,$longitud);
				   					}
				   					else if($aumenta === FALSE && $disminuye === FALSE){
				   						//verificio la longitud de la clave, ya que serán o de longitud dos o 1, y así dependiendo, pues marco
				   						//los caracteres que no pueden ser usados.
				   						//if(mb_strlen($caracter) === 1){
				   							$cadenaSustitucion = mb_substr_replace($cadenaSustitucion, $caracter,$valueArrayPosiPalabra,$longitud);
				   						//}
				   						//no podrán ser modificadas ni ese caracter, ni el siguiente
				   						//else if(mb_strlen($caracter) === 2){
				   						   	//	$cadenaSustitucion = mb_substr_replace($cadenaSustitucion, $caracter,$valueArrayPosiPalabra,$longitud);
			   							//}
			   					}
				   				}
				   			$posicion++;
						}
				   	}
					//cuando termino todos los cambios sobre la palabra, la voy guardando en mi array de cambios.
				   	//para evitar que haya duplicados
				   	if(strcmp($palabra,$cadenaSustitucion)!=0){//sensible a mayusculas y minusculas, pero como está en mayusculas, no problema.
				   		//verifico que la combinacion que venga, no esté ya en el array de cambios.
				   			$array_cambios[$comb] = $cadenaSustitucion;
				   	  		$comb++;
				   	}
					//ya hemos guardado esa palabra, ahora ya las posiciones ocupadas de la anterior palabra no nos interesan
					unset($posicionesOcupadas);
				}	
				//$array_cambios_sin_dupl= array_values(array_unique($array_cambios));	
				$tiempoConstruirCadena = microtime(true);
			
			    foreach($array_cambios as $keyCambios => $valorCambios){
					if($ultimaPalabra===true)
						$cadenaBusqueda = $cadenaBusqueda."* ".$valorCambios;
					else
						$cadenaBusqueda = $cadenaBusqueda." ".$valorCambios;
				}
				$tiempoConstruirCadena2 = microtime(true);
				
			}//endif $numeroCombinaciones<$totalCombinacionesPalabra
			//if(strlen($palabra)>=2){
				if($ultimaPalabra===true){
					$cadenaBusqueda = $cadenaBusqueda."*)";
				}
				else{ 
					$cadenaBusqueda = $cadenaBusqueda. ") ";
				}
			/*}
			else { //longitud <=2 y ultima palabra
				if($ultimaPalabra === true){
					$cadenaBusqueda =$cadenaBusqueda."*) ";
				}
			}*/
				//vacío el array_combinaciones para guardar solo las combinaciones de lo que necesito de la siguiente palabra-.
				unset($array_combinaciones);
				unset($array_cambios);
				unset($combinar);
				unset($numeroIguales);
					
		}//end if sizeof($array_combinaciones)
		else{
			if(strlen($palabra)>=2)
				if($ultimaPalabra === true)
					$cadenaBusqueda = $cadenaBusqueda. '*) ';
		}
		 }
		 $tiempoTodasCombinaciones2 = microtime(true);
		
		//BUSCAMOS EN LA BBDD CON LIKE Y CON REGEXP
		 $inicioConsulta = microtime(true);
		 $matches2 = calles_correos_busqueda_coincidencias($cadenaBusqueda,$provincia,$arrayId);
		 $finalConsulta = microtime(true);
          //ORDENAMOS EL ARRAY CON LAS COMPARACIONES ENCONTRADAS.
    	 if(sizeof($matches1)>0 && sizeof($matches2)>0)
    	 //unifico las dos busquedas encontradas
    	 	$matches = array_merge ($matches1,$matches2);
    	 else if(sizeof($matches1)<1){
    	 	$matches = $matches2;
    	 }
    	 else if(sizeof($matches2)<1) 
    	 	$matches = $matches1;
	 	}
	 	//si busquedaExacta ya devuelve el maximo de registros permitidos ;
	 	//Entonces $matches contendrá el array $matches1 que es el que devolvió la búsqueda Exacta realizada la primera vez, sobre 
	 	//la palabra introducida.
	 	else {
     		$matches = $matches1;
     	}
     	
     $inicioOrdenacion = microtime(true);	
     $inicioOrdenacionLev = microtime(true);	
	 $copiaordenacion = array();
	 $ordenacion = $matches;
   	 $distancia = -1;
 	//for donde ordeno por la distancia de levenshtein
   	 foreach($ordenacion as $key=>$value){
   		$copiaordenacion[$key] =$ordenacion[$key];
  		ordenar_distancia_lev($cad,levenshtein($cad,$ordenacion[$key]['viapobla']),$key,$copiaordenacion); //copiaordenacion va por referencia &$copiaordenacion.
   	}
	$finalOrdenacionLev = microtime(true);
   	//ordenar por impar-inferior : vias con mismo nombre de calle, ciudad, provincia.
   	$inicioOrdenacionImpar = microtime(true);
   	$copia = array();
   	foreach($copiaordenacion as $k=>$v){
   		foreach($copiaordenacion as $k2=>$v2){
    				//tienen la misma via y la misma ciudad. Ordenamos por impar inferior de menos a mas
    		//if($v['idregistro']!== $v2['idregistro']){
   				if(($v['viapobla'] === $v2['viapobla'])){
   					if($v['ciudad'] === $v2['ciudad']){
   						if($v['nimparinf']<=$v2['nimparinf']){
								$copia[$k2]=$copiaordenacion[$k2];
								$copiaordenacion[$k2] = $copiaordenacion[$k];
								$copiaordenacion[$k] = $copia[$k2];
						}//endif ordenar por impar
					}//endif ordenar por ciudad
				}//endif viapobla
    		//}//en if idregistro
   		}//end for each
   	}//end foreach
    $finalOrdenacion = microtime(true);	
   	$finalOrdenacionImpar = microtime(true);		
   			
    $finali = microtime(true); //tiempo total
	$totali = $finali-$inicioi;
	//tiempo consulta
	$totalConsulta = $finalConsulta-$inicioConsulta;
	//total ordenar por lev y por impar
	$totalOrdenacion  = $finalOrdenacion - $inicioOrdenacion;
	//Ordenacion Lev
	$totalOrdenacionLev = $finalOrdenacionLev - $inicioOrdenacionLev;
	//Ordenacion por impar
	$totalOrdenacionImpar = $finalOrdenacionImpar - $inicioOrdenacionImpar;
    //tiempo en hacer todas las modificaciones de la palabra
    $tiempoTodasCombinaciones3 = $tiempoTodasCombinaciones2-$tiempoTodasCombinaciones;
    //tiempo que tarda en coger los datos de $array_cambios
    $tiempoConstruirCadena3 = $tiempoConstruirCadena2 - $tiempoConstruirCadena;
    
    $memoria = memory_get_usage();
	// Quitar desde array_devolver hasta drupal_json 
	//descomentar return 
   /* $array_devolver = array();
   	foreach ($copiaordenacion as $match){
   		
   		$array_devolver[$match['idregistro']] =  		
		  						 '<span class = "muestra_calle"><b>' . $match['tipovia'] . ' ' . '</b></span>' .
		  												  '<span class = "muestra_viapobla">'  . $match['viapobla'] . ' ' . '</span>' .
   		  												  '<span class = "muestra_nimparinf">'	. $match['nimparinf'] . '-' . '</span>'.
   														  '<span class = "muestra_nimparsup">' . $match['nimparsup'] . ' ' . '</span>'.
   														  '<span class = "muestra_nparinf">' . $match['nparinf']. '-' . '</span>'.
   														  '<span class = "muestra_nparsup">' . $match['nparsup'] . ' ' . '</span>'.
		  												  '<span class = "muestra_cp">'. $match['codigo_postal']  . ' ' . '</span>' .
		  												  '<span class = "muestra_descripcion">' . $match['ciudad'] . ' ' . '</span>';
			
	}//end foreach
	
    drupal_json($array_devolver);*/
  return $copiaordenacion;
  
}

function calculoNumeroVeces($palabra,$array_combinaciones,$array_sustituciones,$array_posiciones){
		foreach($array_combinaciones as $clave => $valor){
			//Una vez que ya tengo mi $array_combinaciones con todas las claves posibles, 
			// miro en el array_posiciones todas las posibles combinaciones para buscarlos en la palabra 
			//y ver cuántas hay de cada una. 
			//obtengo el array correspondiente a la clave
			/**
				 * $numeroIguales[key][0] = numero de veces que aparece
				 * $numeroiguales[key][1] = por lo que lo sustituimos
				 * $numeroIguales[key][2] = las posiciones donde aparece;
				 * */
				$numeroIguales[$clave] = array(substr_count($palabra,$clave),$array_sustituciones[$clave]); 
				//$numero iguales contendrá por cada clave el numero de veces que aparece repetido.
				//$numero = 0;
					
			}
	return $numeroIguales;

}

function calculoPosiciones($numeroIguales,$palabra,$array_sustituciones){
	$posOcupadas = array();//añado jueves a ultima hora
	foreach($numeroIguales as $clave => $valor){ 
		$posInicial = 0;
		$posi = 0;
		$posiciones = array();
		
		while(($posAparicion= mb_strpos($palabra,$clave,$posInicial))!== FALSE){
			//caso que sea RR
			//añado jueves a ultima hora.
			//este if es para las claves, que pueden formar parte de otra clave, para que no cuente las posiciones dos veces, y por tanto, 
			//no cree combinaciones innecesarias. 
			
			if(strcmp($clave,'RR') === 0 || strcmp($clave,'NB') === 0 || strcmp($clave,'MB') === 0 || strcmp($clave,'NV') === 0 || strcmp($clave, 'MV') === 0
				|| strcmp($clave,'TX') === 0 || strcmp($clave,'CH') === 0){
				$posiciones[$posi] = $posAparicion;
		 	 	$posi++;
				$posOcupadas[$posAparicion] = 1;
				$posOcupadas[$posAparicion+1] = 1;
			}
			if($posOcupadas[$posAparicion]!=1){
			//esto era lo viejo
		  	 	$posiciones[$posi] = $posAparicion;
		 		$posi++;
			} //siguiente posicion a la que hemos encontrado
			 $posInicial = $posAparicion+1;
	
		} //end while
		if(count($posiciones)>0){ //existe en al menos una posicion de la palabra
			$numeroIguales[$clave][0] = count($posiciones); //actualizo con el numero real de veces que aparece
			$numeroIguales[$clave][2] = $posiciones;
		}
		else //sino,no me interesa. Elimino esa clave, para que no cree combinaciones innecesarias
			unset($numeroIguales[$clave]);
	}
	return $numeroIguales;
}


function mb_substr_replace($string, $replacement, $start, $length = null, $encoding = null)
    {
        if (extension_loaded('mbstring'))
        {
            $string_length = (is_null($encoding)) ? mb_strlen($string) : mb_strlen($string, $encoding);
           
            if ($start < 0){
                $start = max(0, $string_length + $start);
            }
           
            else if ($start > $string_length){
                $start = $string_length;
            }
           /////*****************
            if ($length < 0){
                $length = max(0, $string_length - $start + $length);
            }
           
            else if ((is_null($length)) || ($length > $string_length)){
                $length = $string_length;
            }
           
            if (($start + $length) > $string_length){
                $length = $string_length - $start;
            }
           
            if (is_null($encoding)){
                return mb_substr($string, 0, $start) . $replacement . mb_substr($string, $start + $length, $string_length - $start - $length);
            }
           
            return mb_substr($string, 0, $start, $encoding) . $replacement . mb_substr($string, $start + $length, $string_length - $start - $length, $encoding);
        }
       
        return (is_null($length)) ? substr_replace($string, $replacement, $start) : substr_replace($string, $replacement, $start, $length);
    }

function combinaciones($combinar){

  $posibilidades = array();
  //estamos en el caso base.
  if ( count($combinar) == 1){
    do{
     $posibilidades[] = $combinar[0]; 
 	 }while($combinar[0]--);
 	 return $posibilidades;
  }
  else{
    $combin_resto = combinaciones(array_slice($combinar,1));
    $size = sizeOf($combin_resto) -1;
    do{
      $i = $size;
     	do{
  		 $posibilidades[] =  $combinar[0].'|'.$combin_resto[$i];  
  	 	}while($i--);
  	 }while($combinar[0]--);
  	}
  return $posibilidades;
}


function calles_correos_busqueda_coincidencias($cadenaBusqueda,$provincia,$arrayId){
	
	 $matches = array();
	 $cadena = "(".implode($arrayId,',').")";
	 $sqlInicial = "SELECT CODVIA.descvia,viapobla,idregistro,codigo_postal,CODCIU.descripcion,".
  				   "num_impar_inferior,num_impar_superior,num_par_inferior,num_par_superior FROM {POSTALT}".
  				   " LEFT OUTER JOIN {CODCIU} ON POSTALT.codlocalidad = CODCIU.codlocalidad ".
  				   "LEFT OUTER JOIN {CODVIA} ON POSTALT.codvia = CODVIA.codvia  WHERE";
	//la busqueda inicial no ha devuelto nada. Posibles errores gramaticales.	
		if(empty($provincia)){
			
			if(!empty($arrayId)){

  				$sql = $sqlInicial." idregistro NOT IN $cadena AND ".
  				       "(MATCH(viapobla) AGAINST('%s' IN BOOLEAN MODE)) ".
  				       "ORDER BY (MATCH(viapobla) AGAINST('%s' IN BOOLEAN MODE)) DESC";
  				//$cad tiene algo de la forma +isabel +la +catolica
  				$result = db_query_range($sql,array($cadenaBusqueda,$cadenaBusqueda), 0, 40);
			}
			else{
				$sql = $sqlInicial." (MATCH(viapobla) AGAINST('%s' IN BOOLEAN MODE)) ".
					   "ORDER BY (MATCH(viapobla) AGAINST('%s' IN BOOLEAN MODE)) DESC";
  				//$cad tiene algo de la forma +isabel +la +catolica
  				$result = db_query_range($sql,array($cadenaBusqueda,$cadenaBusqueda), 0, 40);
			}
  		
		}
		else {
	
			if(!empty($arrayId)){
		
				$sql = $sqlInicial." idregistro NOT IN $cadena AND CODCIU.descripcion='%s' and ".
  					   "(MATCH(viapobla) AGAINST('%s' IN BOOLEAN MODE)) ".
  				       "ORDER BY (MATCH(viapobla) AGAINST('%s' IN BOOLEAN MODE)) DESC";
 				$result = db_query_range($sql,array($provincia,$cadenaBusqueda,$cadenaBusqueda), 0, 40);
			}
			else {
				$sql = $sqlInicial." CODCIU.descripcion='%s' and ".
  				       "(MATCH(viapobla) AGAINST('%s' IN BOOLEAN MODE)) ".
  				       "ORDER BY (MATCH(viapobla) AGAINST('%s' IN BOOLEAN MODE)) DESC";
				$result = db_query_range($sql,array($provincia,$cadenaBusqueda,$cadenaBusqueda), 0, 40);
			}
		
		}
    	 // only 15 results will show
    		while ($calleCorreos = db_fetch_object($result)) {
    			//calle por defecto es vacío (viene en las hojas de comentarios de la bbdd
    			if($calleCorreos->descvia==null){
					$calle = "CALLE";
				}
				else{
					$calle = $calleCorreos->descvia;
				}
		  		$matches[$calleCorreos->idregistro] = array("tipovia" => $calle, 
		  		 				                      "viapobla" => $calleCorreos->viapobla,
		  		 				                      "idregistro" => $calleCorreos->idregistro,
		  		 			                          "codigo_postal" => $calleCorreos->codigo_postal,
		  		 				                      "ciudad" => $calleCorreos->descripcion,
		  						                      "nimparinf" => $calleCorreos->num_impar_inferior,
		  						                      "nimparsup" => $calleCorreos->num_impar_superior,
		  						                      "nparinf" => $calleCorreos->num_par_inferior,
		  						                      "nparsup" => $calleCorreos-> num_par_superior);  		
		    } //end while

	return $matches;
	
}

function busquedaExacta($cad){
	//tenemos que poner la $cad de manera que en la primera búsqueda encuentre la cadena tal cual, por tanto, utilizo 
	//". Luego ya buscaré que contenga la palabra en cualquier punto. 
	
	$cad2 = $cad.'%';
	$cad3 = '"'.$cad.'"';
	$sql = "SELECT CODVIA.descvia,viapobla,idregistro,codigo_postal,CODCIU.descripcion,".
  		   "num_impar_inferior,num_impar_superior,num_par_inferior,num_par_superior FROM {POSTALT} ".
  	       "LEFT OUTER JOIN {CODCIU} ON POSTALT.codlocalidad = CODCIU.codlocalidad ".
  		   "LEFT OUTER JOIN {CODVIA} ON POSTALT.codvia = CODVIA.codvia WHERE ".
		   "viapobla like '%s' ". 
		   "ORDER BY viapobla ASC";
		   $result  = db_query_range($sql,$cad2,0,60);
     while ($calleCorreos = db_fetch_object($result)) {
    			//calle por defecto es vacío (viene en las hojas de comentarios de la bbdd
    			if($calleCorreos->descvia==null){
					$calle = "CALLE";
				}
				else{
					$calle = $calleCorreos->descvia;
				}
		  		$matches[$calleCorreos->idregistro] = array("tipovia" => $calle, 
		  		 				                      "viapobla" => $calleCorreos->viapobla,
		  		 				                      "idregistro" => $calleCorreos->idregistro,
		  		 			                          "codigo_postal" => $calleCorreos->codigo_postal,
		  		 				                      "ciudad" => $calleCorreos->descripcion,
		  						                      "nimparinf" => $calleCorreos->num_impar_inferior,
		  						                      "nimparsup" => $calleCorreos->num_impar_superior,
		  						                      "nparinf" => $calleCorreos->num_par_inferior,
		  						                      "nparsup" => $calleCorreos-> num_par_superior);  		
    } //end while

	return $matches;
     
}


function busquedaExacta_antigua($cad){
	  
   $sql = "SELECT CODVIA.descvia,viapobla,idregistro,codigo_postal,CODCIU.descripcion, ".
  	  	  "num_impar_inferior,num_impar_superior,num_par_inferior,num_par_superior FROM {POSTALT} ".
  		  "LEFT OUTER JOIN {CODCIU} ON POSTALT.codlocalidad = CODCIU.codlocalidad ".
  		  "LEFT OUTER JOIN {CODVIA} ON POSTALT.codvia = CODVIA.codvia  WHERE viapobla LIKE '%s' ORDER BY viapobla ASC";
  		  $result = db_query_range($sql,$cad,0,60);
   while ($user = db_fetch_object($result)) {
   		//calle por defecto es vacío (viene en las hojas de comentarios de la bbdd
   		if($user->descvia==null){
			$calle = "CALLE";
		}
	   else{
			$calle = $user->descvia;
	   }
	   
	   $matches[$user->idregistro] = array("tipovia" => $calle, 
		  		 	                 "viapobla" => $user->viapobla,
		  		 				     "idregistro" => $user->idregistro,
		  		 			         "codigo_postal" => $user->codigo_postal,
		  		 				     "ciudad" => $user->descripcion,
		  						     "nimparinf" => $user->num_impar_inferior,
		  						     "nimparsup" => $user->num_impar_superior,
		  						     "nparinf" => $user->num_par_inferior,
		  						     "nparsup" => $user-> num_par_superior);  		
   } //end while

   return $matches;
     
}

 //bucle que cada dos porcentajes sustituya por uno. 
function quitarDoblePorCiento($cadena){
	
	$cadporc = $cadena;
  	while(strpos($cadporc,'%%')!==FALSE){
		$cadporc = str_replace('%%','%',$cadporc);
 	}	
    return $cadporc;
}

function quitarDobleEspacioBlanco($cadena){
	$cadcopia = $cadena;
	while(strpos($cadcopia,'  ')!==FALSE){
		$cadcopia = str_replace('  ',' ',$cadcopia);
	}
	return $cadcopia;
}
//ordenacion distancia de lev 
function ordenar_distancia_lev($cad,$distancia,$key,&$copiaordenacion){
	$copia = array();
   	foreach($copiaordenacion as $key2 =>$value2){
   	
   				//saco la via pobla
   				//cuanto de iguales son $cad(introducida) y la encontrada
   				//$lev = levenshtein($cad,$copiaordenacion[$key2]['viapobla']);
   		if(levenshtein($cad,$copiaordenacion[$key2]['viapobla'])>$distancia){
   			$copia[$key2]=$copiaordenacion[$key2];
   			$copiaordenacion[$key2]=$copiaordenacion[$key];
   		  	$copiaordenacion[$key] = $copia[$key2];
   		}	
	
   	}
}

function calles_correos_errores($string,&$cadena2){
	$cadena1 = $string;
	$patrones = array();
		$patrones[0] = '/[BV]/';
		$patrones[1] = '/(LL|Y|I)/';
		$patrones[2] = '/[GXJ]/';
		$patrones[3] = '/(C|K|QU)/';
		$patrones[4] = '/(N|Ñ)/';
	$sustituciones = array();
		$sustituciones[0] = '[BV]';
		$sustituciones[1] = '(LL|Y|I)';
		$sustituciones[2] = '(G|X|J)';
		$sustituciones[3] = '(C|K|QU)';
		$sustituciones[4] = '(N|Ñ)';
	$cadena = preg_replace($patrones, $sustituciones, $cadena1);
   	$cadena2= preg_replace($patrones, '%', $cadena2);
	return $cadena;
}
//COMPRUEBA EN LA CADENA INTRODUCIDA, QUE SI HAY ESPACIOS, PUEDE TENER ESTA SERIE DE
//PREPOSICIONES O DE ARTICULOS O NADA.
function calles_correos_art_prep($string,&$cadena2){
	
	$cadena1 = $string;
	$patrones = array();
		$patrones[0] = '/ /';
	$sustituciones = array();
		$sustituciones[0] = '( EL | LA | LOS | LAS | EN | UN | DE | DEL | Y | DE EL | DE LA | DE LOS | DE LAS | | ")';
	$cadena = preg_replace($patrones,$sustituciones,$cadena1);
	$cadena2 = preg_replace($patrones,'%',$cadena2);
	return $cadena;
}
//SQL QUE LE PASAMOS LA EXPRESION REGULAR YA FORMADA 
//CON TODAS LOS POSIBLES ERRORES AL INTRODUCIR POR TECLADO.
//HACE LA BUSQUEDA CON REGEXP Y SI ENCUENTRA VALORES, LO DEVUELVE EN UN ARRAY
//DE LA FORMA IDREGISTRO->VIAPOBLA
function calles_correos_busqueda_coincidencias_antigua($string,$compLike,$compLike1,$compLike2,$compLike3,$compLike4,
											$compLike5,$compLike6,$compLike7,$compLike8,$compLike9,$compLike10,
											$compLike11,$compLike12,$provincia,$arrayId){
	$matches = array();
	//$arrayId => array donde guardamos los Id's de la primera busqueda realizada.
	//$cadena una cadena de la forma (idregistro,idregistro,....) para en la segunda búsqueda no tener duplicados
	 $cadena = "(".implode($arrayId,',').")";
	//la busqueda inicial no ha devuelto nada. Posibles errores gramaticales.	
	if ($string) {
		if(empty($provincia)){
			
			
			//vieja....LenTA!!!!!!!
			/*	$ini1 = time();
				
				$sql = "SELECT CODVIA.descvia,viapobla,idregistro,codigo_postal,CODCIU.descripcion,
						num_impar_inferior,num_impar_superior,num_par_inferior,num_par_superior FROM {POSTALT}
						LEFT OUTER JOIN {CODCIU} ON POSTALT.codlocalidad = CODCIU.codlocalidad
						LEFT OUTER JOIN {CODVIA} ON POSTALT.codvia = CODVIA.codvia WHERE viapobla LIKE '%s' AND viapobla REGEXP '%s'";
  				$result = db_query_range(db_rewrite_sql($sql),$compLike,$string, 0, 40);
				$fin1 = time();
				$total1 = $fin1-$ini1;
				drupal_set_message("tiempo select provincia vacia vieja $total1.");*/
			
				
				
			//nueva, válida
			//$ini2 = time();
			if(!empty($arrayId)){
  				$sql = "SELECT CODVIA.descvia,viapobla,idregistro,codigo_postal,CODCIU.descripcion, ".
  						"num_impar_inferior,num_impar_superior,num_par_inferior,num_par_superior FROM {POSTALT} ".
  						"LEFT OUTER JOIN {CODCIU} ON POSTALT.codlocalidad = CODCIU.codlocalidad ".
  				        "LEFT OUTER JOIN {CODVIA} ON POSTALT.codvia = CODVIA.codvia  WHERE idregistro NOT IN $cadena AND (viapobla LIKE '%s' ".
  				        "OR viapobla LIKE '%s' OR viapobla LIKE '%s' OR viapobla LIKE '%s'  OR viapobla LIKE '%s' OR viapobla LIKE '%s' ".
  				        "OR viapobla LIKE '%s' OR viapobla LIKE '%s' OR viapobla LIKE '%s' OR viapobla LIKE '%s' OR viapobla LIKE '%s' ".
  				        "OR viapobla LIKE '%s' OR viapobla LIKE '%s') ".
  				        "AND viapobla REGEXP '%s'";
  				$result = db_query_range($sql,array($compLike,$compLike1,$compLike2,$compLike3,$compLike4,
  						  $compLike5,$compLike6,$compLike7,$compLike8,$compLike9,$compLike10,$compLike11,
  						  $compLike12,$string),0,40);
			}
			else{
				$sql = "SELECT CODVIA.descvia,viapobla,idregistro,codigo_postal,CODCIU.descripcion, ".
  						"num_impar_inferior,num_impar_superior,num_par_inferior,num_par_superior FROM {POSTALT} ".
  						"LEFT OUTER JOIN {CODCIU} ON POSTALT.codlocalidad = CODCIU.codlocalidad ".
  				        "LEFT OUTER JOIN {CODVIA} ON POSTALT.codvia = CODVIA.codvia  WHERE (viapobla LIKE '%s' ". 
  				        "OR viapobla LIKE '%s' OR viapobla LIKE '%s' OR viapobla LIKE '%s'  OR viapobla LIKE '%s' OR viapobla LIKE '%s' ". 
  				        "OR viapobla LIKE '%s' OR viapobla LIKE '%s' OR viapobla LIKE '%s' OR viapobla LIKE '%s' OR viapobla LIKE '%s' ".
  				        "OR viapobla LIKE '%s' OR viapobla LIKE '%s') ".
  				        "AND viapobla REGEXP '%s'";
  				$result = db_query_range($sql,array($compLike,$compLike1,$compLike2,$compLike3,$compLike4,
  						  $compLike5,$compLike6,$compLike7,$compLike8,$compLike9,$compLike10,$compLike11,
  						  $compLike12,$string),0,40);
			}
  
  			/*$fin2 = time();
  			$total2 = $fin2-$ini2;
  			drupal_set_message("tiempo select provincia vacia nuevo $total2.");*/
			
		}
		else {
			//vieja LENTA!!!!!!
	/*	$ini3 = time();
			$sql = "SELECT CODVIA.descvia,viapobla,idregistro,codigo_postal,CODCIU.descripcion,
				num_impar_inferior,num_impar_superior,num_par_inferior,num_par_superior FROM {POSTALT}
				LEFT OUTER JOIN {CODCIU} ON POSTALT.codlocalidad = CODCIU.codlocalidad
				LEFT OUTER JOIN {CODVIA} ON POSTALT.codvia = CODVIA.codvia WHERE CODCIU.descripcion='%s' and viapobla LIKE '%s' AND viapobla REGEXP '%s'";
				$result = db_query_range(db_rewrite_sql($sql),$provincia,$compLike,$string, 0, 40);
			$fin3 = time();
			$total3 = $fin3 - $ini3;
			drupal_set_message("tiempo select provincia no vacia viejo $total3.");
		*/
			//NUEVA, VÁLIDA
			
			if(!empty($arrayId)){
		
				$sql = "SELECT CODVIA.descvia,viapobla,idregistro,codigo_postal,CODCIU.descripcion, ".
  				       "num_impar_inferior,num_impar_superior,num_par_inferior,num_par_superior FROM {POSTALT} ".
  				       "LEFT OUTER JOIN {CODCIU} ON POSTALT.codlocalidad = CODCIU.codlocalidad ".
  				       "LEFT OUTER JOIN {CODVIA} ON POSTALT.codvia = CODVIA.codvia  WHERE idregistro NOT IN $cadena AND CODCIU.descripcion='%s' and (viapobla LIKE '%s' ".
  				       "OR viapobla LIKE '%s' OR viapobla LIKE '%s' OR viapobla LIKE '%s'  OR viapobla LIKE '%s' OR viapobla LIKE '%s' ".
  				       "OR viapobla LIKE '%s' OR viapobla LIKE '%s' OR viapobla LIKE '%s' OR viapobla LIKE '%s' OR viapobla LIKE '%s' ".
  				       "OR viapobla LIKE '%s' OR viapobla LIKE '%s') ".
  				       "AND viapobla REGEXP '%s'";
					$result = db_query_range($sql,array($provincia,$compLike,$compLike1,$compLike2,$compLike3,$compLike4,
							  $compLike5,$compLike6,$compLike7,$compLike8,$compLike8,$compLike9,$compLike10,$compLike11,$compLike12,$string), 0, 40);
			}
			else {
				$sql = "SELECT CODVIA.descvia,viapobla,idregistro,codigo_postal,CODCIU.descripcion, ".
  				       "num_impar_inferior,num_impar_superior,num_par_inferior,num_par_superior FROM {POSTALT} ".
  				       "LEFT OUTER JOIN {CODCIU} ON POSTALT.codlocalidad = CODCIU.codlocalidad ".
  				       "LEFT OUTER JOIN {CODVIA} ON POSTALT.codvia = CODVIA.codvia  WHERE CODCIU.descripcion='%s' and (viapobla LIKE '%s' ".
  				       "OR viapobla LIKE '%s' OR viapobla LIKE '%s' OR viapobla LIKE '%s'  OR viapobla LIKE '%s' OR viapobla LIKE '%s' ".
  				       "OR viapobla LIKE '%s' OR viapobla LIKE '%s' OR viapobla LIKE '%s' OR viapobla LIKE '%s' OR viapobla LIKE '%s' ".
  				       "OR viapobla LIKE '%s' OR viapobla LIKE '%s') ".
  				       "AND viapobla REGEXP '%s'";
					$result = db_query_range($sql,array($provincia,$compLike,$compLike1,$compLike2,$compLike3,$compLike4,
							  $compLike5,$compLike6,$compLike7,$compLike8,$compLike9,$compLike10,$compLike11,$compLike12,$string), 0, 40);
			}
		
		}
    	 // only 15 results will show
    		while ($user = db_fetch_object($result)) {
    			//calle por defecto es vacío (viene en las hojas de comentarios de la bbdd
    			if($user->descvia==null){
					$calle = "CALLE";
				}
				else{
					$calle = $user->descvia;
				}
		  		$matches[$user->idregistro] = 		array("tipovia" => $calle, 
		  		 				  "viapobla" => $user->viapobla,
		  		 				  "idregistro" => $user->idregistro,
		  		 			      "codigo_postal" => $user->codigo_postal,
		  		 				  "ciudad" => $user->descripcion,
		  						  "nimparinf" => $user->num_impar_inferior,
		  						  "nimparsup" => $user->num_impar_superior,
		  						  "nparinf" => $user->num_par_inferior,
		  						  "nparsup" => $user-> num_par_superior);  		
		      		}
    		
  	}
	return $matches;
}
//COMPROBAR QUE TENGAMOS UNA H O NINGUNA EN CUALQUIER POSICION DE LA PALABRA. 
//ASI SE VERIFICA QUE OMITAMOS H INTERCALADAS, AL PRINCIPIO Y DEMÁS.
function calles_correos_faltas_h($cadena,&$copia){

	$longitud = strlen($cadena);
	for($i=0;$i<$longitud;$i++){
		$cadena2 = $cadena2 . 'H?'.mb_substr($cadena,$i,1); //por ejemplo para que no haya problemas con la ñ
	}
	//BUCLE Y CADENA PARA LA COMPARACION DEL LIKE.
	for($j=0;$j<strlen($copia);$j++){
		$copia2=$copia2.'%'.substr($copia,$j,1);
	}
	$copia = $copia2;
	return $cadena2;
}
//ELIMINAR TILDES PALABRA ORIGINAL CASTELLANAS, CATALANAS Y DIERESIS
function calles_correos_eliminar_tildes($string){
	
	$cadena1 = $string;
	$patrones = array();
		$patrones[0] = '/(Á|À|Ä)/';
		$patrones[1] = '/(É|È|Ë)/';
		$patrones[2] = '/(Í|Ì|Ï)/';
		$patrones[3] = '/(Ó|Ò|Ö)/';
		$patrones[4] = '/(Ú|Ù|Ü)/';
	$sustituciones = array();
		$sustituciones[0] = 'A';
		$sustituciones[1] = 'E';
		$sustituciones[2] = 'I';
		$sustituciones[3] = 'O';
		$sustituciones[4] = 'U';
	$cadena = preg_replace ($patrones, $sustituciones,$cadena1);
	return $cadena;
}

//comprueba palabras que se escriben con x pero suenan como j.
//segun lo que he encontrado hay 3 de ese estilo: 
// mexico, oaxaca, texas
//y palabras que tengan nb, mb,mp etc.
function calles_correos_errores_mnb($string,&$cadena2){
	
	$cadena1 = $string;
	$patrones = array();
		$patrones[0] = '/(NB|MB|NV|MV)/';
		$patrones[1] = '/(NP|MP)/';
		$patrones[2] = '/(TX|TZ|CH)/';
		$patrones[3] = '/(GU|G)/';
		$patrones[4] = '/(RR|R)/';
	$sustituciones = array();
		$sustituciones[0] = '(NB|MB|NV|MV)';
		$sustituciones[1] = '(NP|MP)';
		$sustituciones[2] = '(TX|TZ|CH)';
		$sustituciones[3] = '(GU|G)';
		$sustituciones[4] = '(RR|R)';
	$cadena = preg_replace ($patrones, $sustituciones, $cadena1);
	$cadena2=preg_replace($patrones, '%', $cadena2);
	return $cadena;
}

